{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n * @module decorators\n *\n */\n\n\nimport classWrapper from './class_decorator';\nimport methodWrapper from './method_decorator';\nimport methodWrapperScoped from './method_decorator_scoped';\n/**\n * noopDecorator\n *\n * @access private\n * @return {undefined} Returns `undefined` so that the original undecorated instance/method is used\n */\n\nfunction noopDecorator() {\n  return undefined;\n}\n/**\n * _decorator\n *\n * @access private\n * @param {Function} methodFn The method wrapper to delegate to, based on whether user has specified a scoped decorator or not\n * @param {Array} ...args Remainder of arguments passed in\n * @return {Function} The decorated class or method\n */\n\n\nfunction _decorator(methodFn) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  } // check the first argument to see if it's a user-supplied keycode or array\n  // of keycodes, or if it's the wrapped class or method\n\n\n  var testArg = args[0];\n  var isArray = Array.isArray(testArg); // if the test argument is not an object or function, it is user-supplied\n  // keycodes. else there are no arguments and it's just the wrapped class\n\n  if (isArray || ~['string', 'number', 'symbol'].indexOf(typeof testArg === 'undefined' ? 'undefined' : _typeof(testArg))) {\n    var keys = isArray ? testArg : args; // return the decorator function, which on the next call will look for\n    // the presence of a method name to determine if this is a wrapped method\n    // or component\n\n    return function (target, methodName, descriptor) {\n      return methodName ? methodFn({\n        target: target,\n        descriptor: descriptor,\n        keys: keys\n      }) : classWrapper(target, keys);\n    };\n  } else {\n    var WrappedComponent = args[0];\n    var methodName = args[1]; // method decorators without keycode (which) arguments are not allowed.\n\n    if (WrappedComponent && !methodName) {\n      return classWrapper.apply(undefined, args);\n    } else {\n      console.warn(methodName + ': Method decorators must have keycode arguments, so the decorator for this method will not do anything');\n      return noopDecorator;\n    }\n  }\n}\n/**\n * keydownScoped\n *\n * Method decorator that will look for changes to its targeted component's\n * `keydown` props to decide when to trigger, rather than responding directly\n * to keydown events. This lets you specify a @keydown decorated class higher\n * up in the view hierarchy for larger scoping of keydown events, or for\n * programmatically sending keydown events as props into the components in order\n * to trigger decorated methods with matching keys.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\n\n\nfunction keydownScoped() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _decorator.apply(undefined, [methodWrapperScoped].concat(args));\n}\n/**\n * keydown\n *\n * The main decorator and default export, handles both classes and methods.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\n\n\nfunction keydown() {\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _decorator.apply(undefined, [methodWrapper].concat(args));\n}\n\nexport default keydown;\nexport { keydownScoped };","map":null,"metadata":{},"sourceType":"module"}