{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * @module store\n *\n */\n\n\nimport matchKeys from './lib/match_keys';\nimport parseKeys from './lib/parse_keys';\nimport uuid from './lib/uuid';\n/**\n * private\n *\n */\n// dict for class prototypes => bindings\n\nvar _handlers = new Map(); // all mounted instances that have keybindings\n\n\nvar _instances = new Set(); // for testing\n\n\nexport function _resetStore() {\n  _handlers.clear();\n\n  _instances.clear();\n}\n/**\n * activate\n *\n * @access public\n * @param {object} instance Instantiated class that extended React.Component, to be focused to receive keydown events\n */\n\nexport function activate(instances) {\n  var instancesArray = [].concat(instances); // if no components were found as ancestors of the event target,\n  // effectively deactivate keydown handling by capping the set of instances\n  // with `null`.\n\n  if (!instancesArray.length) {\n    _instances.add(null);\n  } else {\n    _instances.delete(null); // deleting and then adding the instance(s) has the effect of sorting the set\n    // according to instance activation (ascending)\n\n\n    instancesArray.forEach(function (instance) {\n      _instances.delete(instance);\n\n      _instances.add(instance);\n    });\n  }\n}\n;\n/**\n * deleteInstance\n *\n * @access public\n * @param {object} target Instantiated class that extended React.Component\n * @return {boolean} The value set.has( target ) would have returned prior to deletion\n */\n\nexport function deleteInstance(target) {\n  _instances.delete(target);\n}\n;\nexport function findBindingForEvent(event) {\n  if (!_instances.has(null)) {\n    var keyMatchesEvent = function keyMatchesEvent(keySet) {\n      return matchKeys({\n        keySet: keySet,\n        event: event\n      });\n    }; // loop through instances in reverse activation order so that most\n    // recently activated instance gets first dibs on event\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = [].concat(_toConsumableArray(_instances)).reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var instance = _step.value;\n        var bindings = getBinding(instance.constructor.prototype);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = bindings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                keySets = _step2$value[0],\n                fn = _step2$value[1];\n\n            if (keySets.some(keyMatchesEvent)) {\n              // return when matching keybinding is found - i.e. only one\n              // keybound component can respond to a given key code. to get around this,\n              // scope a common ancestor component class with @keydown and use\n              // @keydownScoped to bind the duplicate keys in your child components\n              // (or just inspect nextProps.keydown.event).\n              return {\n                fn: fn,\n                instance: instance\n              };\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n;\n/**\n * getBinding\n *\n * @access public\n * @param {object} target Class used as key in dict of key bindings\n * @return {object} The object containing bindings for the given class\n */\n\nexport function getBinding(_ref) {\n  var __reactKeydownUUID = _ref.__reactKeydownUUID;\n  return _handlers.get(__reactKeydownUUID);\n}\n;\n/**\n * getInstances\n *\n * @access public\n * @return {set} All stored instances (all mounted component instances with keybindings)\n */\n\nexport function getInstances() {\n  return _instances;\n}\n;\n/**\n * isEmpty\n *\n * @access public\n * @return {number} Size of the set of all stored instances\n */\n\nexport function isEmpty() {\n  return !_instances.size;\n}\n;\n/**\n * setBinding\n *\n * @access public\n * @param {object} args All arguments necessary to set the binding\n * @param {array} args.keys Key codes that should trigger the fn\n * @param {function} args.fn The callback to be triggered when given keys are pressed\n * @param {object} args.target The decorated class\n */\n\nexport function setBinding(_ref2) {\n  var keys = _ref2.keys,\n      fn = _ref2.fn,\n      target = _ref2.target;\n  var keySets = parseKeys(keys);\n  var __reactKeydownUUID = target.__reactKeydownUUID;\n\n  if (!__reactKeydownUUID) {\n    target.__reactKeydownUUID = uuid();\n\n    _handlers.set(target.__reactKeydownUUID, new Map([[keySets, fn]]));\n  } else {\n    _handlers.get(__reactKeydownUUID).set(keySets, fn);\n  }\n}\n;","map":null,"metadata":{},"sourceType":"module"}